# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)



# What is Reactjs?

A JavaScript library for building user interfaces

JavaScript ka library hai jiske madad se humlog Website ka fornted banate hai.

# who develop React

FaceBook

it is maintained by Facebook and open source Community

# Current Version of React

version 18

# The 2023 React Developer Roadmap 

### 1.  Knowledge of HTML + CSS + Javascript (
  You should have mid to high level knowledge of HTML +CSS + Javascript including ECMA 6)

### 2. Have General Development Skill
You Should Have Knowledge of ##GIT
You Should Know How to Use ##CommandLine(CLI)
You Should Know How to Create Projects and It Structure
Know HTTP(S) protocol you should at least be familiar with common HTTP request methods like the GET, POST, PUT, PATCH, DELETE, OPTIONS, and how HTTP/HTTPS works in general.
Algorithms and Data Structure
Well, this is again one of the general programming skill which is not necessarily needed for becoming a React developer but absolutely needed to become a programmer in the first place.
Learn Design Patterns

### 3. Understand What React Is
You should understand what is so special about ReactJs. It is a declarative, component-based user interface library.

### 4. Learn How to Set Up your Development Environment
There are multiple ways to set up a development environment for ReactJs. Minimally, you can point to the CDN distribution from your script file.

### 5. Components
how To Create / pass value / import / reuse Component

### 6. jsx
how to write Code In JSX i.e where to define HTML where to define Js Code



### 7. State in React
State is the data private to your component. We do not share states across components. The "state" of your component that you use to render information and modify information.

### 8.  Props in React
In real-world programming, you will need the components to interact with each other. States are private to a component, but you need to pass the data between components. 

### 9.  Lists and Keys in React
We use list to render a list of items in a React component. It is a very common task to list users, TODO items, and other things. We use the map() function to iterate over the list and render the results.

keys help identify what item from the list has changed to inform React to re-render. ReactJS gives a warning if you forget to mention the keys for a list.

### 10.  Life Cycle Methods in React
We discussed that the "state" is a component's private matter. State can be dynamic and might need modifications. We also need to perform resource cleanups when components are destroyed. ReactJs provides various life-cycle methods to detect the phases and take action.

If you are just getting started with ReactJS, you should understand life cycle management for functional components. You can do this using the in-built hooks like useState, useEffect, and so on.

### 11. Styling in React
We all want our applications to look fresh and aesthetically pleasing. You can use plain old CSS to style your ReactJS app. Or you can use Sass or other CSS-driven component libraries like TailwindCSS, ChakraUI, react-bootstrap, or MUI. The choice is entirely yours.

### 12. Form Handling in React
Handling forms is an essential requirement in web applications. You need to understand how to handle form elements in the ReactJS way.

### 13. Routing in React
Routing is required for multi-page applications. It is also helpful to bookmark a particular page or traverse back-and-forth in the application using the browser's back button.

React Router is the most popular routing solution that helps with declarative routing.

### 14.  Data Handling in React
This is a crucial part of application development. You need to learn how to use the fetch API or libraries like node-fetch and axios to interact with APIs and handle data in your component.

### 15.  Reconciliation Process in React
ReactJS uses the Virtual DOM and diffing algorithm to decide when and what to update in the actual DOM for the rendering. Knowing how it works under the hood will help you with debugging.

### 16.  React Hooks
You hopefully learned a bit about some in-built hooks like useState useEffect when you learn about the life-cycle. There are other useful built-in hooks you need to learn with use-cases. Make sure you don't ignore them.

### 17. Custom React Hooks
Custom hooks helps in reusability. You must look for opportunities to extract out component logic to reusable hooks. The code becomes clean and modular with the usage of custom hooks.

### 18. Context in React
In React applications, we pass data from parent to child components. It is one-directional and top-down. If too many components are deep down, the data (props) must pass through many components.

Also, if you need to share some values between components that are not part of a hierarchy, you need a mechanism. That's when you can make use of the Context.

### 19. Lazy Loading in React
ReactJS supports code splitting. It is a way to lazy load what you need by the current user. It also avoids producing a large build bundle. The dynamic import feature is the best way to include code-splitting in a React app.

### 20. Portals in React
You may have to use Portals when dealing with modals, dialogs, or tooltips with better event handling. It is supported out-of-the-box in ReactJS.

### 21. State Management in React
In a larger application, you must share information between components. At times, the default support of Props and Context may not suffice.

In these cases, you may need a state management solution like Redux or MobX in these cases. But again, you can decide whether (or not) you'll need them.

### 22. Theming in React
Theming is a modern feature in web apps. We should give users the choice of what theme they want – like light or dark – to use to help them feel comfortable when using your site or app.

You can even create your custom themes in some applications and apply them. There are several ways you can theme a React app. Select the one that matches the best with your application's CSS stack.

### 23. Patterns in React
There are various patterns you can use as solutions to common problems in React. Over time, ReactJS developers have found patterns they could use to help them stop reinventing the wheel.

### 24. nti-Patterns in React
Anti-Patterns are the practices that you should avoid using in the ReactJS applications. You should learn them along with the helpful patterns you should use.

Just keep in mind that learning advanced React concepts doesn't stop here. You can continue to learn about accessibility, test frameworks, and many more advanced concepts as needed.

# Popular Framework Build Using React

1. Next.js
2. GatsbyJS
3. Remix


 # What is component in React?


React component is the primary building block of the React application. It uses React elements and JSX to design its user interface. 
React component is basically a JavaScript class or pure JavaScript function

Example 
```html
export default function App(){
  return (
    <> 
      <div> Hello World
    </>
  )
}

```

# what is JSX

JSX stands for JavaScript XML.
JSX allows us to write HTML in React.
JSX makes it easier to write and add HTML in React.

JSX ek trika hai jo humlog jiske madad se JavaScript file me Drict Html likh sakte hai.
 JSX is faster than normal JavaScript as it performs optimizations while translating to regular JavaScript
 jsk se application thoda speed ho jata hai



# How React Use Virtual DOM and gain high performence

Virtual DOM exists which is like a lightweight copy of the actual DOM. So for every object that exists in the original DOM, there is an object for that in React Virtual DOM. 
It is exactly the same, but it does not have the power to directly change the layout of the document.
and when we do any changes react Virtual Dom Update That particular Area of Real Dom not Other Placs
Manipulating DOM is slow, but manipulating Virtual DOM is fast as nothing gets drawn on the screen.
in this way react Increase Performence of the React Application



# One-way Data Binding:

 One-way data binding gives you better view over your application. In This way Data Flow from View to Controller(Js) or Controller to View

# what is single page application (spa)

A single page application is a website or web application that dynamically rewrites a current web page with new data from the web server, instead of the default method of a web browser loading entire new pages.

singal page application wo hota hai jo ke jis part ko change karna chahe whi chenge hoga bs.

# Some Popular Application Build On React

Facebook, popular social media application
Instagram, popular photo sharing application
Netflix, popular media streaming application
Code Academy, popular online training application
Reddit, popular content sharing application

# what we need to Install React

Node js version 14+ should be installed in our machine

# command to create react Application

npx create-react-app <App Name>  // <App Name> us the Name of your Application

### to create react app on same folder

npx create-react-app .

# What Knowledge we need to Learn React

1. HTML and CSS
2. Javascript
3. Ecma 6


 # Basic Concerpt of ECMA6 (ES6)

 added feature like let and Const for variable declaration

## Arrow Functions

Arrow functions allow us to write shorter function syntax:
Example
### Before:
const hello = function() {
  return "Hello World!";
}
### With Arrow Function:
const hello = () => {
  return "Hello World!";
}
### Arrow Functions Return Value by Default:

hello = () => "Hello World!";

### Arrow Function With Parameters:

const hello = function(val) {
  return "Hello " + val;
}

hello = (val) => "Hello " + val;
Example

### Arrow Function Without Parentheses:

hello = val => "Hello " + val;


## Array Methods

There are many JavaScript array methods.
One of the most useful in React is the .map() array method.
The .map() method allows you to run a function on each item in the array, returning a new array as the result.
 
### In React, map() can be used to generate lists.
Example
Generate a list of items from an array:
const myArray = ['apple', 'banana', 'orange'];
const myList = myArray.map((item) => <p>{item}</p>)
React Example for Map
import React from 'react';
import ReactDOM from 'react-dom/client';

const myArray = ['apple', 'banana', 'orange'];

const myList = myArray.map((item) => <p>{item}</p>)

<p>apple</p>
<p>banana</p>
<p>orange</p>

const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(myList);


## Destructuring

To illustrate destructuring, we'll make a sandwich. Do you take everything out of the refrigerator to make your sandwich? No, you only take out the items you would like to use on your sandwich.

Destructuring is exactly the same. We may have an array or object that we are working with, but we only need some of the items contained in these.

Destructuring makes it easy to extract only what is needed.
Destructuring Objects
Here is the old way of using an object inside a function:

Example
Before:

const vehicleOne = {
  brand: 'Ford',
  model: 'Mustang',
  type: 'car',
  year: 2021, 
  color: 'red'
}

myVehicle(vehicleOne);

// old way
function myVehicle(vehicle) {
  const message = 'My ' + vehicle.type + ' is a ' + vehicle.color + ' ' + vehicle.brand + ' ' + vehicle.model + '.';
}
Here is the new way of using an object inside a function:

Example
With destructuring:

const vehicleOne = {
  brand: 'Ford',
  model: 'Mustang',
  type: 'car',
  year: 2021, 
  color: 'red'
}

myVehicle(vehicleOne);

function myVehicle({type, color, brand, model}) {
  const message = 'My ' + type + ' is a ' + color + ' ' + brand + ' ' + model + '.';
}

Notice that the object properties do not have to be declared in a specific order.

We can even destructure deeply nested objects by referencing the nested object then using a colon and curly braces to again destructure the items needed from the nested object:

Example
const vehicleOne = {
  brand: 'Ford',
  model: 'Mustang',
  type: 'car',
  year: 2021, 
  color: 'red',
  registration: {
    city: 'Houston',
    state: 'Texas',
    country: 'USA'
  }
}

myVehicle(vehicleOne)

function myVehicle({ model, registration: { state } }) {
  const message = 'My ' + model + ' is registered in ' + state + '.';
}

## Spread Operator

The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object into another array or object.

const numbersOne = [1, 2, 3];
const numbersTwo = [4, 5, 6];

const numbersCombined = [...numbersOne, ...numbersTwo];

#### numbersCombined = [1,2,3,4,5,6];

Combine these two objects:

const myVehicle = {
  brand: 'Ford',
  model: 'Mustang',
  color: 'red'
}

const updateMyVehicle = {
  type: 'car',
  year: 2021, 
  color: 'yellow'
}

const myUpdatedVehicle = {...myVehicle, ...updateMyVehicle}

#### myUpdatedVehicle = {
     brand: 'Ford',
  model: 'Mustang',
  type: 'car',
  year: 2021, 
  color: 'yellow'
}



## Modules

JavaScript modules allow you to break up your code into separate files.
This makes it easier to maintain the code-base.
ES Modules rely on the import and export statements.

### Export
You can export a function or variable from any file.
Let us create a file named person.js, and fill it with the things we want to export.
There are two types of exports: Named and Default.
Named Exports
You can create named exports two ways. In-line individually, or all at once at the bottom.
Example
In-line individually:
person.js
export const name = "Jesse"
export const age = 40
All at once at the bottom:
person.js
const name = "Jesse"
const age = 40
export { name, age }

### Import

You can import modules into a file in two ways, based on if they are named exports or default exports.
Named exports must be destructured using curly braces. Default exports do not.
Example
Import named exports from the file person.js:
import { name, age } from "./person.js";
Example
Import a default export from the file message.js:
import message from "./message.js";

## Ternary Operator

The ternary operator is a simplified conditional operator like if / else.
Syntax: 
```html
condition ? <expression if true> : <expression if false>
Here is an example using if / else:
Before:
if (authenticated) {
  renderApp();
} else {
  renderLogin();
}
With Ternary 
authenticated ? renderApp() : renderLogin();
```

# JSX
```html
let x = "hello"
<>
       
       <HTML>
        <Body>{x} </Body>
        </HTML> 
</>
this will compile to

    <html>
        <body> hello</body>
    </html>
```

# React Router

React Router enables "client side routing".

### example of Routing In React
Client side routing is enabled by creating a Router and linking/submitting to pages with Link and <Form>:
```html
import * as React from "react";
import { createRoot } from "react-dom/client";
import {
  createBrowserRouter,
  RouterProvider,
  Route,
  Link,
} from "react-router-dom";

const router = createBrowserRouter([
  {
    path: "/",
    element: (
      <div>
        <h1>Hello World</h1>
        <Link to="about">About Us</Link>
      </div>
    ),
  },
  {
    path: "about",
    element: <div>About</div>,
  },
]);

createRoot(document.getElementById("root")).render(
  <RouterProvider router={router} />
);
```
# createBrowserRouter
This is the recommended router for all React Router web projects. It uses the DOM History API to update the URL and manage the history stack.

# routerprovider
All data router objects are passed to this component to render your app and enable the rest of the data APIs.

# Route
<Router> is the low-level interface that is shared by all router components (like <BrowserRouter> and <StaticRouter>). In terms of React, <Router> is a context provider that supplies routing information to the rest of the app.

# Link
A <Link> is an element that lets the user navigate to another page by clicking or tapping on it. In react-router-dom, a <Link> renders an accessible <a> element with a real href that points to the resource it's linking to. This means that things like right-clicking a <Link> work as you'd expect. You can use <Link reloadDocument> to skip client side routing and let the browser handle the transition normally (as if it were an <a href>).

# How to Include Bootstrap In Application

index.js

via CDN : 
paste it at the end of Head tag 
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
paste it at the end of Body Tags
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>

Notes : You can use Traditional Bootstrap to design your Page

#  Install Bootstrap via NPM

npm install bootstrap@5.3.1 

then in index.js page

import "../node_modules/bootstrap/dist/css/bootstrap.css"

# We can Add Component Based React Bootstrap by using react-bootstrap

https://react-bootstrap.netlify.app/docs/getting-started/introduction

The best way to consume React-Bootstrap is via the npm package which you can install with npm (or yarn if you prefer).

If you plan on customizing the Bootstrap Sass files, or don't want to use a CDN for the stylesheet, it may be helpful to install vanilla Bootstrap as well.

### npm install react-bootstrap bootstrap


# Importing Bootstrap Components 
You should import individual components like: react-bootstrap/Button rather than the entire library. Doing so pulls in only the specific components that you use, which can significantly reduce the amount of code you end up sending to the client.

import Button from 'react-bootstrap/Button';

// or less ideally
import { Button } from 'react-bootstrap';

# Browser globals
We provide react-bootstrap.js and react-bootstrap.min.js bundles with all components exported on the window.ReactBootstrap object. These bundles are available on jsDelivr, as well as in the npm package.
```html
<script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js" crossorigin></script>

<script
  src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"
  crossorigin></script>

<script
  src="https://cdn.jsdelivr.net/npm/react-bootstrap@next/dist/react-bootstrap.min.js"
  crossorigin></script>

<script>var Alert = ReactBootstrap.Alert;</script>


# Examples

import Badge from 'react-bootstrap/Badge';
import Button from 'react-bootstrap/Button';

function Example() {
  return (
    <div>
      <h1>
        Example heading
        <Badge bg="secondary" as={Button}>
          New
        </Badge>
      </h1>
    </div>
  );
}

export default Example;
```
# Important Step to follow when we copy Generic HTML into React JSX

1. class should change to className
2. href="#" should change to href="/"
3. all tag should be closed tag for example 
```html
<input type="" > should have cloas tage  <input type"" />
<br> should be like <br />
<hr> should be <hr/>
```

# why JSX used className for CSS class
to remove comflict between Javascript class and HTML Css class

# Built-in React Hooks
Hooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.

# State Hooks 
State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.

To add state to a component, use one of these Hooks:

useState declares a state variable that you can update directly.
useReducer declares a state variable with the update logic inside a reducer function.
function ImageGallery() {
  const [index, setIndex] = useState(0);

Hooks were added to React in version 16.8.

Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.

Hooks allow us to "hook" into React features such as state and lifecycle methods.

Example:Get your own React.js Server
Here is an example of a Hook. Don't worry if it doesn't make sense. We will go into more detail in the next section.

import React, { useState } from "react";
import ReactDOM from "react-dom/client";
```html
function FavoriteColor() {
  const [color, setColor] = useState("red");

  return (
    <>
      <h1>My favorite color is {color}!</h1>
      <button
        type="button"
        onClick={() => setColor("blue")}
      >Blue</button>
      <button
        type="button"
        onClick={() => setColor("red")}
      >Red</button>
      <button
        type="button"
        onClick={() => setColor("pink")}
      >Pink</button>
      <button
        type="button"
        onClick={() => setColor("green")}
      >Green</button>
    </>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<FavoriteColor />);
```

ou must import Hooks from react.

Here we are using the useState Hook to keep track of the application state.

State generally refers to application data or properties that need to be tracked.

# Hook Rules
There are 3 rules for hooks:

Hooks can only be called inside React function components.
Hooks can only be called at the top level of a component.
Hooks cannot be conditional

# React useState Hook

The React useState Hook allows us to track state in a function component.

State generally refers to data or properties that need to be tracking in an application.

Import useState
To use the useState Hook, we first need to import it into our component.

Example:Get your own React.js Server
At the top of your component, import the useState Hook.

Initialize useState
We initialize our state by calling useState in our function component.

useState accepts an initial state and returns two values:

The current state.
A function that updates the state.
Example:
Initialize state at the top of the function component.
```html
import { useState } from "react";

function FavoriteColor() {
  const [color, setColor] = useState("");
}
```
Notice that again, we are destructuring the returned values from useState.

The first value, color, is our current state.

The second value, setColor, is the function that is used to update our state.

These names are variables that can be named anything you would like.

Lastly, we set the initial state to an empty string: useState("")

```html
Example:
Use the state variable in the rendered component.

import { useState } from "react";
import ReactDOM from "react-dom/client";

function FavoriteColor() {
  const [color, setColor] = useState("red");

  return <h1>My favorite color is {color}!</h1>
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<FavoriteColor />);
```

# Update State
To update our state, we use our state updater function.

We should never directly update state. Ex: color = "red" is not allowed.

Example:
Use a button to update the state:
```html
import { useState } from "react";
import ReactDOM from "react-dom/client";

function FavoriteColor() {
  const [color, setColor] = useState("red");

  return (
    <>
      <h1>My favorite color is {color}!</h1>
      <button
        type="button"
        onClick={() => setColor("blue")}
      >Blue</button>
    </>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<FavoriteColor />);

Example:
Create a single Hook that holds an object:

import { useState } from "react";
import ReactDOM from "react-dom/client";

function Car() {
  const [car, setCar] = useState({
    brand: "Ford",
    model: "Mustang",
    year: "1964",
    color: "red"
  });

  return (
    <>
      <h1>My {car.brand}</h1>
      <p>
        It is a {car.color} {car.model} from {car.year}.
      </p>
    </>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Car />);
```

Updating Objects and Arrays in State
When state is updated, the entire state gets overwritten.

What if we only want to update the color of our car?

If we only called setCar({color: "blue"}), this would remove the brand, model, and year from our state.

We can use the JavaScript spread operator to help us.

Example:
Use the JavaScript spread operator to update only the color of the car:

```html
import { useState } from "react";
import ReactDOM from "react-dom/client";

function Car() {
  const [car, setCar] = useState({
    brand: "Ford",
    model: "Mustang",
    year: "1964",
    color: "red"
  });

  const updateColor = () => {
    setCar(previousState => {
      return { ...previousState, color: "blue" }
    });
  }

  return (
    <>
      <h1>My {car.brand}</h1>
      <p>
        It is a {car.color} {car.model} from {car.year}.
      </p>
      <button
        type="button"
        onClick={updateColor}
      >Blue</button>
    </>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Car />);
```
# React useEffect Hooks

The useEffect Hook allows you to perform side effects in your components.

Some examples of side effects are: fetching data, directly updating the DOM, and timers.

useEffect accepts two arguments. The second argument is optional.

useEffect(<function>, <dependency>)

Let's use a timer as an example.

Example:Get your own React.js Server
Use setTimeout() to count 1 second after initial render:
```html
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setTimeout(() => {
      setCount((count) => count + 1);
    }, 1000);
  });

  return <h1>I've rendered {count} times!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Timer />);
```
But wait!! It keeps counting even though it should only count once!

useEffect runs on every render. That means that when the count changes, a render happens, which then triggers another effect.

This is not what we want. There are several ways to control when side effects run.

We should always include the second parameter which accepts an array. We can optionally pass dependencies to useEffect in this array.

Example
1. No dependency passed:

useEffect(() => {
  //Runs on every render
});
Example
2. An empty array:

useEffect(() => {
  //Runs only on the first render
}, []);
Example
3. Props or state values:

useEffect(() => {
  //Runs on the first render
  //And any time any dependency value changes
}, [prop, state]);
So, to fix this issue, let's only run this effect on the initial render.

Example:
Only run the effect on the initial render:
```html
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setTimeout(() => {
      setCount((count) => count + 1);
    }, 1000);
  }, []); // <- add empty brackets here

  return <h1>I've rendered {count} times!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Timer />);
```
Example:
Here is an example of a useEffect Hook that is dependent on a variable. If the count variable updates, the effect will run again:
```html
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function Counter() {
  const [count, setCount] = useState(0);
  const [calculation, setCalculation] = useState(0);

  useEffect(() => {
    setCalculation(() => count * 2);
  }, [count]); // <- add the count variable here

  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>+</button>
      <p>Calculation: {calculation}</p>
    </>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Counter />);
```
If there are multiple dependencies, they should be included in the useEffect dependency array.

Effect Cleanup
Some effects require cleanup to reduce memory leaks.

Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.

We do this by including a return function at the end of the useEffect Hook.

Example:
Clean up the timer at the end of the useEffect Hook:
```html
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    let timer = setTimeout(() => {
    setCount((count) => count + 1);
  }, 1000);

  return () => clearTimeout(timer)
  }, []);

  return <h1>I've rendered {count} times!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Timer />);
```
Note: To clear the timer, we had to name it.

Test Yourself With Exercises
Exercise:
What do you need to add to the second argument of a useEffect Hook to limit it to running only on the first render?
```html
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [data, setData] = useState([]);

  useEffect(() => {
    setData(getData())
  }, 
);

  return <DisplayData data={data} />;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```
# make HTTP get Call In React 
```html
import { useState,React,useEffect } from "react"
import axios from "axios";
import Card from 'react-bootstrap/Card';
const baseURL = "https://jsonplaceholder.typicode.com/posts";

function Dashboard() {
    /*
        To perform this request when the component mounts, you use the useEffect hook. This involves importing Axios, using the .get() method to make a GET request to your endpoint, and using a .then() callback to get back all of the response data.
        The response is returned as an object. The data (which is in this case a post with id, title, and body properties) is put in a piece of state called post which is displayed in the component.
    */
    const [post, setPost] = useState(null);

    useEffect(() => {
      axios.get(baseURL).then((response) => {
        setPost(response.data);
      });
    }, []);
  
    if (!post) return null;

    const postList= post.map((eachPost)=>
        <Card>
            <Card.Body>
                <Card.Title>{eachPost.id} : {eachPost.title}</Card.Title>
                <Card.Text>
                    {eachPost.body}
                </Card.Text>
            </Card.Body>
        </Card>
    )

    return (
        <>
           <div className="container-fluid">
                <h1> Dashboard </h1>
                <div>
                    {postList}
                </div>
            </div>
        </>
    )
}
export default  Dashboard
```









